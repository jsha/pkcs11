package p11ez

import (
	"errors"
	"sync"

	"github.com/miekg/pkcs11"
)

// Session represents a PKCS#11 session.
type Session struct {
	sync.Mutex
	ctx    *pkcs11.Ctx
	handle pkcs11.SessionHandle
}

// FindObject finds a single object in the token that match the attributes in
// the template. It returns error if there is not exactly one result, or if
// there was an error during the find calls.
func (s *Session) FindObject(template []*pkcs11.Attribute) (Object, error) {
	objects, err := s.FindObjects(template)
	if err != nil {
		return Object{}, nil
	}
	if len(objects) > 1 {
		return Object{}, errors.New("too many objects matching template")
	}
	return objects[0], nil
}

// FindObjects finds any objects in the token
func (s *Session) FindObjects(template []*pkcs11.Attribute) ([]Object, error) {
	s.Lock()
	defer s.Unlock()
	if err := s.ctx.FindObjectsInit(s.handle, template); err != nil {
		return nil, err
	}

	objectHandles, moreAvailable, err := s.ctx.FindObjects(s.handle, 1000)
	if err != nil {
		return nil, err
	}
	if moreAvailable {
		return nil, errors.New("too many objects returned from FindObjects")
	}
	if err = s.ctx.FindObjectsFinal(s.handle); err != nil {
		return nil, err
	} else if len(objectHandles) == 0 {
		return nil, errors.New("no objects found")
	}
	results := make([]Object, len(objectHandles))
	for i, oh := range objectHandles {
		results[i] = Object{
			session:      s,
			objectHandle: oh,
		}
	}
	return results, nil
}

// Close closes the session.
func (s *Session) Close() error {
	s.Lock()
	defer s.Unlock()
	return s.ctx.CloseSession(s.handle)
}

type userType uint

const (
	// SecurityOfficer represents the Security Officer role on the token, for use
	// in Login.
	SecurityOfficer userType = userType(pkcs11.CKU_SO)
	// RegularUser represents the User role on the token, for use in Login.
	RegularUser userType = userType(pkcs11.CKU_USER)
	// ContextSpecificUser is used in Login when reauthenticating.
	ContextSpecificUser userType = userType(pkcs11.CKU_CONTEXT_SPECIFIC)
)

// Login logs into the session as the given user type (SecurityOfficer or
// RegularUser) with the provided PIN.
func (s *Session) Login(userT userType, pin string) error {
	s.Lock()
	defer s.Unlock()
	return s.ctx.Login(s.handle, uint(userT), pin)
}

// Logout logs out of the session.
func (s *Session) Logout() error {
	s.Lock()
	defer s.Unlock()
	return s.ctx.Logout(s.handle)
}

// GenerateRandom returns random bytes generated by the token.
func (s *Session) GenerateRandom(length int) ([]byte, error) {
	s.Lock()
	defer s.Unlock()
	return s.ctx.GenerateRandom(s.handle, length)
}

// CreateObject creates an object on the token with the given attributes.
func (s *Session) CreateObject(template []*pkcs11.Attribute) (Object, error) {
	s.Lock()
	defer s.Unlock()
	oh, err := s.ctx.CreateObject(s.handle, template)
	if err != nil {
		return Object{}, err
	}
	return Object{
		session:      s,
		objectHandle: oh,
	}, nil
}

// InitPIN initialize's the normal user's PIN.
func (s *Session) InitPIN(pin string) error {
	s.Lock()
	defer s.Unlock()
	return s.ctx.InitPIN(s.handle, pin)
}

// SetPIN modifies the PIN of the logged-in user.
func (s *Session) SetPIN(old, new string) error {
	s.Lock()
	defer s.Unlock()
	return s.ctx.SetPIN(s.handle, old, new)
}

// GenerateKey generates a secret key, creating a new key object.
func (s *Session) GenerateKey(mechanism pkcs11.Mechanism, template []*pkcs11.Attribute) (Object, error) {
	s.Lock()
	defer s.Unlock()
	oh, err := s.ctx.GenerateKey(s.handle, []*pkcs11.Mechanism{&mechanism}, template)
	if err != nil {
		return Object{}, err
	}
	return Object{
		session:      s,
		objectHandle: oh,
	}, nil
}

// KeyPair contains two Objects: one for a public key and one for a private key.
// It casts these to the PublicKey and PrivateKey types so they can by used for
// appropriate cryptographic operations.
type KeyPair struct {
	Public  PublicKey
	Private PrivateKey
}

// GenerateKeyPairRequest contains the fields used to generate a key pair.
type GenerateKeyPairRequest struct {
	Mechanism            pkcs11.Mechanism
	PublicKeyAttributes  []*pkcs11.Attribute
	PrivateKeyAttributes []*pkcs11.Attribute
}

// GenerateKeyPair generates a public/private key pair. It takes
// GenerateKeyPairRequest instead of individual arguments so that attributes for
// public and private keys can't be accidentally switched around.
func (s *Session) GenerateKeyPair(request GenerateKeyPairRequest) (*KeyPair, error) {
	s.Lock()
	defer s.Unlock()
	pubHandle, privHandle, err := s.ctx.GenerateKeyPair(s.handle,
		[]*pkcs11.Mechanism{&request.Mechanism},
		request.PublicKeyAttributes,
		request.PrivateKeyAttributes)
	if err != nil {
		return nil, err
	}
	return &KeyPair{
		Public: PublicKey(Object{
			session:      s,
			objectHandle: pubHandle,
		}),
		Private: PrivateKey(Object{
			session:      s,
			objectHandle: privHandle,
		}),
	}, nil
}
